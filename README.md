##设计原则
1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起；
2. 针对接口编程（针对超类型编程），而不是针对实现编程，
3. 多用组合，少用继承
4. 为交互对象之间的松耦合设计而努力
5. 开放-关闭原则，对扩展开放，对修改关闭
6. 要依赖抽象，不要依赖具体类。不能让高层组件（由其底层组件定义其行为的类）依赖底层组件，而且，
   不管高层组件还是底层组件，两者都应该依赖于抽象。实例化一个对象时，就是在依赖它的具体类。
   
##依赖倒置原则
1. 变量不可以持有具体类的引用。使用new就会持有具体类的引用，可以改用工厂来避开。
2. 不要让类派生自具体类。若派生自具体类，就会依赖具体类，派生一个抽象（接口或抽象类）。
3. 不要覆盖基类中已实现的方法。若覆盖了基类，那么该基类就不是一个真正适合该继承的抽象，
基类中已实现的部分应该由所有的子类共享。

##指导方针
1. 变量不可以持有具体类的引用
2. 不要让类派生自具体类
3. 不要覆盖基类中已实现的方法
注意：若具体类是一个不会改变的类，直接实例化没什么影响；

##策略模式
    定义了算法族，分别封装起来，让他们之间可以互相替换，让算法的变化独立于使用算法的客户，类的方法可以看做是
    对象拥有的技能，算法，而不是单纯的行为。
#####原则应用
    1. 会改变的是对象的行为（算法/技能）；
    2. 利用接口将行为或算法分别封装，对象可以动态改变；
    3. 对象和算法之间是“有一个”的关系。
    
***************************
##观察者模式
    在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。
#####注意事项
    1）主题（观察者）用一个共同的接口来更新观察者；
    2）观察者与可观察者之间松耦合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口；
    3）可观察者可以调用接口来通知观察者状态改变，观察者自己从可观察者拉数据；
    4）不可以依赖通知的顺序。
#####原则应用
    1. 会改变的是主题的状态，以及观察者的数目和类型。在该模式中，可以改变依赖于主题状态的对象，
    却不必改变主题。这就叫提前规划。
    2. 观察者利用主题的接口向主题注册，可观察者利用观察者的接口通知观察者。
    3. 利用组合将许多观察者组合进主题中，对象之间的这种关系不是通过基础产生的，
    而是在运行时利用组合的方式而产生的。

***************************
##装饰者模式
    动态地将责任附加到对象上。想要扩展功能，装饰者提供有利于继承的另一种选择。
#####要点 
    1）继承属于扩展之一，但不见得是达到弹性设计的最佳方式；
    2）在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码；
    3）组合和委托可用于运行时动态地加上新的行为；
    4）除了继承，装饰者模式也可以让我们扩展行为；
    5）装饰者模式意味着一群装饰者类，这些类用来包装具体组件；
    6）装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）；
    7）装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代；
    8）可以用无数个装饰者包装一个组件；
    9）装饰者一般对组件的客户是透明的，除非客户查询依赖于组件的具体类型；
    10）会导致设计中出现许多小对象，若过度使用，会让程序变得很复杂。
   
****************************
##工厂模式
    
###简单工厂
    遵循开放-关闭原则，将变化的创建对像的过程封装，将不变的过程与具体类松解藕。
###工厂方法模式
    定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类实例化推迟到子类。
    通过让子类决定创建的对象时什么，来达到将对象创建的过程封装的目的，
    "abstract Pruduct factoryMethod(Object param);"
#####组成元素
    创建者(Creator)类
    定义了一个抽象的工厂方法，让子类实现此方法制造产品，通常包含依赖于对象产品的代码，而这些抽象产品是由子类制造，
    创建者不需要真的知道在制造那种具体产品。
    产品(Product)类
    具体的产品，由抽象创建者子类决定具体制造那种产品。
###抽象工厂模式
    提供一个接口，用于创建相关或依赖对象的家族（可以理解为制造产品所需的一切资源），而不需要明确指定具体类。
    抽象工厂中的方法实际都可以看做是一个工厂方法。
   
#####要点
    1）所有的工厂都是用来封装对象的创建，工厂方法和抽象工厂都负责创建对象。
    2）简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦；
    3）工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
    4）抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。
    5）所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。
    6）工厂方法允许类将实例化延迟到子类进行。
    7）抽象工厂创建相关的对象家族，而不需要依赖他们的具体类。
    8）依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象。
    9）工厂帮助我们针对抽象编程，而不是针对具体编程。
    
********************************

##单件模式
    确保一个类只有一个实例，并提供一个全局访问点。
    public class Singleton{
        private static Singleton singleton;
        private Singleton() {}
        public static Singleton getInstance() {
            if (singleton == null) {
                singleton = new Singleton();
            }
            return singleton;
        }
    }
    此种方式为延迟实例化，在多线程中，可能会导致实例化多个对象，需进行同步。
###延迟实例化
    在使用该对象时才创建。
####同步getInstance方法
    在getInstance()使用频繁的地方，性能较低。
    public class Singleton{
            private static Singleton singleton;
            private Singleton() {}
            public static synchronized Singleton getInstance() {
                if (singleton == null) {
                    singleton = new Singleton();
                }
                return singleton;
            }
        }
####双重检查加锁
    在对象尚未创建时才进行同步。
    public class Singleton{
            private static volitile Singleton singleton;
            private Singleton() {}
            public static Singleton getInstance() {
                if (singleton == null) {
                    synchronized(Singleton.class) {
                        if (singleton == null) {
                           singleton = new Singleton();
                        } 
                    }
                }
                return singleton;
            }
        }
        
###“急切”实例化
    在JVM加载这个类时，马上创建此唯一的单件实例，保证在任何线程访问uniqueInstance静态变量之前，先创建此实例。
    在创建或运行时方面负担不繁重是可以采用该方法。
    public class Singleton{
        provate static Singleton singleton = new Singleton();
        
        private Singleton(){
        }
        
        public static Singleton getInstance() {
            return singleton;
        }
    
    }
    
###要点
    1）单件模式确保程序中一个类最多只有一个实例；
    2）单件模式也提供访问这个实例的全局点；
    3）在Java中实现单件模式需要私有的构造器，一个静态方法和静态变量；
    4）确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，已解决多线程的问题；
    5）小心，如果使用多个类加载器，可能导致单件失效而产生多个实例。
    